package com.blog4java.hsqldb;

import com.blog4java.common.DbUtils;
import org.apache.ibatis.datasource.unpooled.UnpooledDataSource;
import org.hsqldb.jdbc.JDBCDriver;
import org.junit.Before;
import org.junit.Test;

import java.sql.*;

/**
 * Jdbc执行流程：
 *      1.注册驱动
 *      2.创建连接
 *      3.获取数据库操作对象
 *      4.执行sql
 *      5.处理结果集
 *      6.关闭连接
 */
public class LearnJdbcExample {

    @Before
    public void initData() {
        DbUtils.initData();
    }

    @Test
    public void testJdbc() {
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            //1.注册驱动的方式：
            //      a.显式加载驱动类, 激活静态代码块.（静态代码块在类加载时执行，只执行一次）
//            Class.forName("org.hsqldb.jdbcDriver");
            //      b.手动注册
//            DriverManager.registerDriver(new JDBCDriver());
            //      c.jdbc4.0的SPI机制
//            无需注册，在DriverManager的静态代码块中loadInitialDrivers()自动完成注册【ServiceLoader.load(Driver.class)】

            //2.获取连接的方式：
            //      a.DriverManager.getConnection()
//            Connection connection = DriverManager.getConnection("jdbc:hsqldb:mem:mybatis", "sa", "");
            //      b.DataSource.getConnection()
            UnpooledDataSource dataSource = new UnpooledDataSource(JDBCDriver.class.getClassLoader(), "org.hsqldb.jdbcDriver", "jdbc:hsqldb:mem:mybatis", "sa", "");
            connection = dataSource.getConnection();

            String selectSql = "select * from user";

            //3.创建数据库操作对象
            //      a. createStatement() 执行普通sql
//            Statement statement = connection.createStatement();
            //      a. prepareStatement() 执行预编译的sql
//            preparedStatement = connection.prepareStatement(sql);
            //      a. prepareCall() 调用储存过程
//            CallableStatement callableStatement = connection.prepareCall(sql);

            //ResultSet类型：
            //      1.TYPE_FORWARD_ONLY 这种类型的ResultSet不可滚动，游标只能向前移动
            //      2.TYPE_SCROLL_INSENSITIV 这种类型的ResultSet是可滚动的，它的游标可以相对于当前位置向前或向后移动，也可以移动到绝对位置。
            //                               当ResultSet没有关闭时，ResultSet的修改对数据库不敏感，也就是说对ResultSet对象的修改不会影响对应的数据库中的记录。
            //      3.TYPE_SCROLL_SENSITIVE  这种类型的ResultSet是可滚动的，它的游标可以相对于当前位置向前或向后移动，也可以移动到绝对位置。
            //                               当ResultSet没有关闭时，对ResultSet对象的修改会直接影响数据库中的记录。

            //ResultSet并行性：
            //      1.CONCUR_READ_ONLY 为ResultSet对象设置这种属性后，只能从ResulSet对象中读取数据，但是不能更新ResultSet对象中的数据。
            //      2.CONCUR_UPDATABLE 该属性表明，既可以从ResulSet对象中读取数据，又能更新ResultSet中的数据。

            //ResultSet可保持性：
            //      1.HOLD_CURSORS_OVER_COMMIT 当调用Connection对象的commit()方法时，不关闭当前事务创建的ResultSet对象。
            //      2.CLOSE_CURSORS_AT_COMMIT 当前事务创建的ResultSet对象在事务提交后会被关闭，对一些应用程序来说，这样能够提升系统性能。
            preparedStatement = connection.prepareStatement(selectSql,
                    ResultSet.TYPE_FORWARD_ONLY,
                    ResultSet.CONCUR_READ_ONLY,
                    ResultSet.CLOSE_CURSORS_AT_COMMIT);

            //4.执行sql
            //  execute 通过返回值判断SQL类型
            //      当返回值为true时，说明SQL语句为SELECT语句，可以通过Statement接口中的getResultSet()方法获取查询结果集；
            //      否则为UPDATE、INSERT或者DELETE语句，可以通过Statement接口中的getUpdateCount()方法获取影响的行数。
            //  execute(String sql)
            //  execute(String sql, int autoGeneratedKeys)
            //      autoGeneratedKeys参数用于指定自动生成的键是否能够被检索，取值为Statement.RETURN_GENERATED_KEYS或
            //      Statement.NO_GENERATED_KEYS。当参数值为Statement.RETURN_GENERATED_KEYS时，INSERT语句自动生成的键能够被检索.
            //  execute(String sql, int columnIndexes[])
            //  execute(String sql, String columnNames[])
            //      columnIndexes、columnNames指定哪些字段中自动生成的键能够被检索

            //  批量sql语句执行，通过addBatch(String sql)方法添加需要执行的sql,最后调用executeBatch()执行
            //  executeBatch()

            //  如果数据库支持返回的更新数量大于Integer.MAX_VALUE，则需要调用executeLargeUpdate()方法。
            //  executeLargeBatch()
            //  executeLargeUpdate(String sql)
            //  executeLargeUpdate(String sql, int autoGeneratedKeys)
            //  executeLargeUpdate(String sql, int columnIndexes[])
            //  executeLargeUpdate(String sql, String columnNames[])

            //  执行select操作
            //  executeQuery(String sql)

            //  执行update、insert、delete操作
            //  executeUpdate(String sql)
            //  executeUpdate(String sql, int autoGeneratedKeys)
            //  executeUpdate(String sql, int columnIndexes[])
            //  executeUpdate(String sql, String columnNames[])
            resultSet = preparedStatement.executeQuery();

            //5.处理结果集
            //ResultSet中常用的游标操作
            //  1.游标移动
            //      next()                  游标向前移动一行
            //      previous()              游标向后移动一行
            //      first()                 游标移动到第一行
            //      last()                  移动游标到最后一行
            //      beforeFirst()           移动游标到ResultSet对象的第一行之前
            //      afterLast()             游标位置移动到ResultSet对象最后一行之后
            //      relative(int rows)      相对于当前位置移动游标
            //      absolute(int row)       游标定位到ResultSet对象中的第row行
            //  2.修改ResultSet对象
            //    操作步骤：1.使用游标移动方法，找到需要修改的row
            //             2.使用updateXX()方法更新字段
            //             3.使用updateRow()方法将修改应用到数据库
            //      updateRow()             更新ResultSet记录中的某一行,如果在并行性级别为ResultSet.CONCUR_READ_ONLY的ResultSet对象上调用更新方法，将会抛出SQLException异常
            //      deleteRow()             删除ResultSet记录中的某一行
            //      insertRow()             在ResultSet中插入一行
            //      moveToCurrentRow()      将光标移动到插入前的行
            //      moveToInsertRow()       将光标移动到插入行，当游标位于插入行上时，只能调用 updater、getter 和insertRow方法。每次在调用insertRow之前调用此方法时，都必须为结果集中的所有列赋予一个值。在对列值调用 getter 方法之前，必须先调用 updater 方法。
            while (resultSet.next()) {
//                System.out.println(resultSet.getMetaData());
                ResultSetMetaData metaData = resultSet.getMetaData();
                System.out.print(metaData.getColumnLabel(1) + "=" + resultSet.getString(1) + "\t");
                System.out.print(metaData.getColumnLabel(2) + "=" + resultSet.getString(2) + "\t");
                System.out.print(metaData.getColumnLabel(3) + "=" + resultSet.getString(3) + "\t");
                System.out.print(metaData.getColumnLabel(4) + "=" + resultSet.getString(4) + "\t");
                System.out.print(metaData.getColumnLabel(5) + "=" + resultSet.getString(5) + "\t");
                System.out.println(metaData.getColumnName(6) + "=" + resultSet.getString(6));
            }

            //region jdbc中的事务管理的几个概念
            //  1.提交模式(autoCommit属性)      手动提交、自动提交
            connection.setAutoCommit(false);
            String insertSql = "insert into user values (14, '2010-10-26 10:20:30', 'User15', 'test', '18700001111', 'User15')";
            preparedStatement = connection.prepareStatement(insertSql);
            preparedStatement.executeUpdate();
            connection.commit();

            //  2.事务隔离级别    不支持事务(TRANSACTION_NONE)、读未提交(TRANSACTION_READ_UNCOMMITTED)、读已提交(TRANSACTION_READ_COMMITTED)、可重复读(TRANSACTION_REPEATABLE_READ)、串行化(TRANSACTION_SERIALIZABLE)
            connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);

            // 查询结果
            String countSql = "select count(*) from user";
            preparedStatement = connection.prepareStatement(countSql);
            resultSet = preparedStatement.executeQuery();
            resultSet.next();
            System.out.println("user table count is " + resultSet.getInt(1));

            // 3.保存点  savepoint
            connection.setAutoCommit(false);
            Savepoint savepoint = connection.setSavepoint();
            String deleteSql = "delete from user where name = 'User15'";
            preparedStatement = connection.prepareStatement(deleteSql);
            connection.rollback(savepoint);
            connection.commit();

            // 查询结果
            preparedStatement = connection.prepareStatement(countSql);
            resultSet = preparedStatement.executeQuery();
            resultSet.next();
            System.out.println("user table count is " + resultSet.getInt(1));
            //endregion
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            //6.关闭连接，释放资源
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (SQLException e) {
                    throw new RuntimeException(e);
                }
            }
            if (preparedStatement != null) {
                try {
                    preparedStatement.close();
                } catch (SQLException e) {
                    throw new RuntimeException(e);
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (SQLException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }

}
